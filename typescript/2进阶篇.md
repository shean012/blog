# 进阶篇

typescript 是结构化类型系统，了解 结构化类型系统 是学习类型编辑的关键，这个概念会支撑起整个篇章的内容，特别重要！

目录：
<li><a href="#structure">了解结构化类型系统</a></li>
<li><a href="#typeLevel">类型层级</a></li>
<li><a href="#conditionType">条件类型</a></li>
<li><a href="#extends">关于extends关键字</a></li>
<li><a href="#reload">函数重载</a></li>
<li><a href="#infer">infer</a></li>
<li><a href="#func">协变与逆变</a></li>

<h2 id="structure">结构化类型系统</h2>
直接看例子：

```
// case1
interface Man {
    run: () => void;
}

interface Woman {
    run: () => void;
}

const manList: Man[] = [];
const shean: Man = {
    run: () => { ... }
}
const staller: Woman = {
    run: () => { ... }
}
manList.push(shean, staller); // ==> success

// case2
class Cat {
  eat() { }
}

class Dog {
  eat() { }
}

function feedCat(cat: Cat) { }

feedCat(new Dog())
```
通过这两个例子，我们可以看出，typeScript 比较两个类型并非通过类型的名称，而是比较这两个类型上实际拥有的属性与方法。如果A上的属性，在B上都存在，那么B是有可能分配给A的。所以为什么 case2 中，明明是个猫，塞只狗进去都可以。这就是 typeScript 的类型系统特性：结构化类型系统（鸭子类型）；<br/>
但为什么我说可能呢，是因为如果 Dog 这个类存在一个 Cat 类上不存在的属性，那么这个传参就不能成立了。或者 Dog 类的 eat 方法会返回一个 number 类型， 而 Cat 类的 eat 方法返回的却是一个string; 这样同样无法满足;
> 函数类型的比较 会涉及到 类型系统中的协变与逆变 我们在下面的小节中讲解。

<h2 id="typeLevel">类型层级</h2>

通过上面的例子，我们了解了结构化类型系统的特性，某个类型能不能分配给到一个变量或者属性，看的是他们是否存在相同的属性。不过我们再深入去思考一下，在之前基础篇中，我有提到如果想让我们的类型约束更加精准，我们可以将类型精准成字面量类型。
```
interface Test1 {
  name: string;
  age: number
};

interface Test2 {
  name: string;
  age: 16 | 18 | 20;
}

const obj: Test1 = {
  name: "shean",
  age: 27
} // --> success 

const obj: Test2 = {
  name: "shean",
  age: 27
} // --> fail 这里会报错，因为 age 不匹配
```
我们思考这个例子，我们是通过字面量精准的约束了我们的接口，同时这里也引出了一个 ts 的一个特性，就是类型兼容性的问题，而类型兼容性就是根据类型层级的判断的。
低层级的类型可以被高层级的类型兼容。<br/>
因为字面量类型层级比原始类型的层级低，所以我们将 obj 这个变量分配给 Test2 就出错了。当然这个例子不严谨，这个结果也是因为我们使用了字面量类型去约束它导致的。

<h2 id="conditionType">条件类型</h2>

条件类型类似我们平时的 三元表达式：
```
A === B ? C : D;
A extends B ? C : D;
```
很相似，但是不一样。因为三元对比的是是否相等，而条件类型对比的是，是否兼容，我们并不需要它们的类型完全相等，只需要具有兼容性，而两个完全相同的类型，其 extends 自然也是成立的。<br/>
条件类型类型编程的关键，为何这么说呢？首先我们的思考，我们为何使用 ts 。我们使用它是因为我们希望我们的代码更加健壮，与此同时我们希望我们在日后维护代码的时候，进行迭代升级的时候，我们有更好的提示，和更完备的逻辑约束。那何谓更加完备的逻辑约束呢？<br/>
如果现在我定一个函数fn, 这个函数接收一个参数 test, 这个参数有可能是 string、number、boolean 类型，然后它的返回值会根据它的类型变化，进行变化。如果要你定义这样一个函数你可能第一个时间想到了 泛型 ，然后写出以下代码;
```
type FN<T> = (test: T) => T;
```
不过很快你就发现这个代码是有问题的，因为返回值不一定和传入的 test 一样；此时你可能会用上篇介绍的 联合类型 进行优化，然后写出下面的代码。
```
type FN = (test: string | number | boolean) => string | number | boolean;
```
这样的代码确实可以应付上面说的所有情况，而且约束了输入和输出。但很遗憾，只能告诉你。这个代码虽然应付了ts的类型检查，但却没啥意义。此时你可能会问，都满足了需求了，为啥毫无意义呢？（思考一下...）<br/>
因为这个代码在日后调用的时候，根本起不了什么约束作用，因为我们的入参是不固定的，所以我们的返回值会受入参的变化，而变化。如果这个类型在多个地方被用上了，而我希望的逻辑是 当我传入的 test 是 number 类型的时候，我需要输出的结果是一个 string 类型的值。但是此时你定义的返回值是一个联合类型，所以就算你返回的是一个 number 类型。编译依然可以通过的。试想一下，如果时间长了，你迭代需求，同样使用这个类型。这个类型其实毫无意义的。我们使用 ts 就是为了减少我们代码错误，增加健壮性。虽然这个类型定义得可以应付 ts 的检测，但是在我看来索然无味，真正类型编程的艺术，应是增强逻辑的完备性。这个才是对 ts 的深入理解。<br>
那要怎么写才能补全逻辑的完备性呢？我们将上面的两种方法都用上，同时加上条件类型进行判断
```
type Fn<T extends string | number> = (arg: T) => T extends string ? boolean : T extends number ? string : number;

const fnc1: Fn<string> = (arg) => {
   return false // success
};
// 通过字面量类型进行约束，使这个函数更加精准
const fnc2: Fn<"test"> = (arg) => {
    return false; // success
};

/** 
 * 看这个错误的例子，如果我们现在定义 fnc3 传入的 arg 要求的是一个 string ，按照我们的定义的 Fn 类型，这个函数的返回结果，必须是一个 boolean 类型。
 * 但是如果我将返回值，写成了 number 类型。则无法编译。因为它无法满足条件类型。
 * **/ 
const fnc3: Fn<string> = (arg) => {
    return "true"; // fail
 }

// 当我们需要定义传入 number 类型的参数的函数时
const fnc4: Fn<number> = (num) => { 
    return "result" // success
}


fnc1("run"); // => success 
fnc2("test"); // => success 因为使用了 字面量的 泛型约束，这里传入的值 就只能是 test
fnc4(111); // success

```


<h2 id="extends">关于extends关键字</h2>
这里补充说明一下，看到上一小节中的例子，我们可以看到 extends 关键字，如果在泛型坑位里面使用，是可以做作判断的，用于定义我们的泛型约束。

<h2 id="reload">函数重载</h2>

<h2 id="infer">infer</h2>
<h2 id="func">协变与逆变</h2>