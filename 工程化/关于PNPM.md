### 关于 PNPM

因为最近公司很多小伙伴都问我有关 pnpm 的问题，这里我也说说我对它的理解。<br>
#### pnpm的优势:

1. 更加合理的依赖管理
2. 可以节省磁盘空间 （结合软硬连接，不会重复安装相同的包）
#### npm、yarn 存在的依赖问题：
为何说pnpm的依赖管理是更加合理的，首先我们看看 npm 和 yarn 存在的问题：<br>
我们在 package.json 中安装的包会拍平的列在 node_module 中，这是为了解决以前 `node_module` 层级过深的问题。因为以前我们依赖中的依赖，是在依赖的 node_module 里面的，这样一层层叠下去，不过在 windows 机器上会出问题，所以就有了拍平的方案。不过拍平会衍生出新问题，就是因为子依赖和依赖同层。所以我们是能够直接引用子依赖的，这样的话，我们的代码就有可能出现严重问题。试想一下，我们引用了一个第三方库，例如 `lodash.js` 而 `lodash.js` 引用了 `monent.js`。而我们在项目中直接使用了 `monent.js`。若果有一天 `lodash.js` 不用  `monent.js` 了。我们的代码就会报错。<br>
而 `pnpm` 不会在 `node_module` 中拉平包依赖，而是将所有的子依赖放到 .pnpm 的文件夹中。所以我们就不会出现直接引用依赖包的子依赖的情况。保障了代码的安全。

#### 节省磁盘空间
因为 yarn 和 npm 是将子依赖拉平放到 `node_module` 中的。而区分这些子依赖的方法便是通过包名，相同的依赖包，只有下载一份。如果出现相同的依赖，但是版本不相同的情况的话，`node_module`中只会下载最先下载的的那个版本。而其他版本的依赖包，会存在依赖它的那个包的 `node_module` 文件夹下，这样就会导致一个问题。这些不同版本的子依赖包，会下载很多次，因为他们都是存在于他们的各自的依赖包下的。但是 `pnpm` 不会存在这个问题。因为它区分子依赖并不是通过包名。依赖包会通过软链接的方式，链接到依赖项。所以它取什么名字并不重要。所以 `pnpm` 并不会造成子依赖重复下载的问题。
#### 简便地实现 monorepo 
其实 `pnpm` 对 `monorepo` 的支持是十分友好的，因为`pnpm`提供了 `workspace`，所以如果我们想使用 `monorepo` 方式来管理我们的项目，会十分简便。
这里简单的介绍一下 `monorepo`；
如果我们有一个项目，同时有 移动端、管理端、pc端。他们其实有很多公共组件的，或相同的公用方法，但是我们需要重复的将这3个项目重新构建。做了好多重复的动作，这明显不符合我们的要求。这时我们可以使用 monorepo 来管理我们的不同的项目。我们可以将 公用的组件和方法 进行抽离。然后我们在各个项目中应用抽离出去的这些公用模块。不但我们可以节省时间，而且当我们需要对其中一个组件或者函数进行修改的时候，可以同时覆盖到我们所有的项目中去。



